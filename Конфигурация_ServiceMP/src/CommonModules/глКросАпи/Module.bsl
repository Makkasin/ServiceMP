Функция Токен()
	Возврат "Bearer 9A7FD50D-1070-40DA-9FDF-125DD7E071B2";
КонецФункции


Функция ПрочитатьGZip(СжатыеДанные) Экспорт
	
	РазмерПрефиксаGZip = 10;
	РазмерПостфиксаGZip = 8;
	
	ЧтениеДанных = Новый ЧтениеДанных(СжатыеДанные);
	ЧтениеДанных.Пропустить(РазмерПрефиксаGZip);
	
	РазмерСжатыхДанных = ЧтениеДанных.ИсходныйПоток().Размер() - РазмерПрефиксаGZip - РазмерПостфиксаGZip; 
	
	ПотокZip = Новый ПотокВПамяти(ZipРазмерLFH() + РазмерСжатыхДанных + ZipРазмерDD() + ZipРазмерCDH() + ZipРазмерEOCD());
	ЗаписьДанных = Новый ЗаписьДанных(ПотокZip);
	ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(ZipLFH());
	ЧтениеДанных.КопироватьВ(ЗаписьДанных, РазмерСжатыхДанных);
	
	ЗаписьДанных.Закрыть();
	ЗаписьДанных = Новый ЗаписьДанных(ПотокZip);
	
	CRC32 = ЧтениеДанных.ПрочитатьЦелое32();
	РазмерНесжатыхДанных = ЧтениеДанных.ПрочитатьЦелое32();
	ЧтениеДанных.Закрыть();
	
	ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(ZipDD(CRC32, РазмерСжатыхДанных, РазмерНесжатыхДанных));
	ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(ZipCDH(CRC32, РазмерСжатыхДанных, РазмерНесжатыхДанных));
	ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(ZipEOCD(РазмерСжатыхДанных));
	ЗаписьДанных.Закрыть();
		
	Возврат ПрочитатьZip(ПотокZip);

КонецФункции

// Описание структур см. здесь https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT
Функция ZipРазмерLFH()
	
	Возврат 34;
	
КонецФункции

Функция ZipРазмерDD()
	
	Возврат 16;
	
КонецФункции

Функция ZipРазмерCDH()
	
	Возврат 50;
	
КонецФункции

Функция ZipРазмерEOCD()
	
	Возврат 22;
	
КонецФункции

Функция ZipLFH()
	
	// Local file header
	Буфер = Новый БуферДвоичныхДанных(ZipРазмерLFH());
	Буфер.ЗаписатьЦелое32(0, 67324752); // signature 0x04034b50
	Буфер.ЗаписатьЦелое16(4, 20);       // version
	Буфер.ЗаписатьЦелое16(6, 10);       // bit flags	
	Буфер.ЗаписатьЦелое16(8, 8);        // compression method
	Буфер.ЗаписатьЦелое16(10, 0);       // time
	Буфер.ЗаписатьЦелое16(12, 0);       // date
	Буфер.ЗаписатьЦелое32(14, 0);       // crc-32
	Буфер.ЗаписатьЦелое32(18, 0);       // compressed size
	Буфер.ЗаписатьЦелое32(22, 0);       // uncompressed size
	Буфер.ЗаписатьЦелое16(26, 4);       // filename legth - "data"
	Буфер.ЗаписатьЦелое16(28, 0);       // extra field length
	Буфер.Записать(30, ПолучитьБуферДвоичныхДанныхИзСтроки("data", "ascii", Ложь));
	
	Возврат Буфер;
	
КонецФункции

Функция ZipDD(CRC32, РазмерСжатыхДанных, РазмерНесжатыхДанных)
	
	// Data descriptor
	Буфер = Новый БуферДвоичныхДанных(ZipРазмерDD());
	Буфер.ЗаписатьЦелое32(0, 134695760);
	Буфер.ЗаписатьЦелое32(4, CRC32);
	Буфер.ЗаписатьЦелое32(8, РазмерСжатыхДанных);
	Буфер.ЗаписатьЦелое32(12, РазмерНесжатыхДанных);
	
	Возврат Буфер;
	
КонецФункции

Функция ZipCDH(CRC32, РазмерСжатыхДанных, РазмерНесжатыхДанных)
	
	// Central directory header
	Буфер = Новый БуферДвоичныхДанных(ZipРазмерCDH());
	Буфер.ЗаписатьЦелое32(0, 33639248);              // signature 0x02014b50
	Буфер.ЗаписатьЦелое16(4, 798);                   // version made by
	Буфер.ЗаписатьЦелое16(6, 20);                    // version needed to extract
	Буфер.ЗаписатьЦелое16(8, 10);                    // bit flags
	Буфер.ЗаписатьЦелое16(10, 8);                    // compression method
	Буфер.ЗаписатьЦелое16(12, 0);                    // time
	Буфер.ЗаписатьЦелое16(14, 0);                    // date
	Буфер.ЗаписатьЦелое32(16, CRC32);                // crc-32
	Буфер.ЗаписатьЦелое32(20, РазмерСжатыхДанных);   // compressed size
	Буфер.ЗаписатьЦелое32(24, РазмерНесжатыхДанных); // uncompressed size
	Буфер.ЗаписатьЦелое16(28, 4);                    // file name length
	Буфер.ЗаписатьЦелое16(30, 0);                    // extra field length
	Буфер.ЗаписатьЦелое16(32, 0);                    // file comment length
	Буфер.ЗаписатьЦелое16(34, 0);                    // disk number start
	Буфер.ЗаписатьЦелое16(36, 0);                    // internal file attributes
	Буфер.ЗаписатьЦелое32(38, 2176057344);           // external file attributes
	Буфер.ЗаписатьЦелое32(42, 0);                    // relative offset of local header
	Буфер.Записать(46, ПолучитьБуферДвоичныхДанныхИзСтроки("data", "ascii", Ложь));
	
	Возврат Буфер;

КонецФункции

Функция ZipEOCD(РазмерСжатыхДанных)
	
	// End of central directory
	РазмерCDH = 50;
	Буфер = Новый БуферДвоичныхДанных(ZipРазмерEOCD());
	Буфер.ЗаписатьЦелое32(0, 101010256); // signature 0x06054b50
	Буфер.ЗаписатьЦелое16(4, 0); // number of this disk
	Буфер.ЗаписатьЦелое16(6, 0); // number of the disk with the start of the central directory
	Буфер.ЗаписатьЦелое16(8, 1); // total number of entries in the central directory on this disk
	Буфер.ЗаписатьЦелое16(10, 1); // total number of entries in the central directory
	Буфер.ЗаписатьЦелое32(12, РазмерCDH); // size of the central directory	
	// offset of start of central directory with respect to the starting disk number
	Буфер.ЗаписатьЦелое32(16, ZipРазмерLFH() + РазмерСжатыхДанных + ZipРазмерDD()); 
	Буфер.ЗаписатьЦелое16(20, 0); // the starting disk number
	
	Возврат Буфер;
	
КонецФункции

Функция ПрочитатьZip(СжатыеДанные, ТекстОшибки = Неопределено)
	
#Если МобильноеПриложениеСервер Тогда
	ВызватьИсключение(НСтр("ru = 'Работа с Zip-файлами в мобильной платформе не поддерживается'"));
#Иначе
	Каталог = ПолучитьИмяВременногоФайла();
	ЧтениеZip = Новый ЧтениеZipФайла(СжатыеДанные);
	ИмяФайла = ЧтениеZip.Элементы[0].Имя;
	Попытка
		ЧтениеZip.Извлечь(ЧтениеZip.Элементы[0], Каталог, РежимВосстановленияПутейФайловZIP.НеВосстанавливать);
	Исключение
		// Игнорируем проверку целостности архива, просто читаем результат
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	ЧтениеZip.Закрыть();
	
	Результат = Новый ДвоичныеДанные(Каталог + ПолучитьРазделительПути() + ИмяФайла);
	УдалитьФайлы(Каталог);
	
	Возврат Результат;
#КонецЕсли
	
КонецФункции

Функция ХЕЛП()
	
		Возврат "<!DOCTYPE HTML PUBLIC ""-//W3C//DTD HTML 4.0 Transitional//EN"">
		|<HTML>
		|<HEAD>
		|<META HTTP-EQUIV=""Content-Type"" CONTENT=""text/html; CHARSET=utf-8""/>
		|<TITLE></TITLE>Неверный тип данных в теле запроса.  <br />
		|  Шаг 1. метод ""CRBRAND"" - возвращает список брендов по переданому артикулу <br />
		| В теле запроса нужна Структура(""Арт"") - тип текст; <br />
		|  <br />
		|  Шаг 2. метод ""CRITEMS"" - возвращает список аналогов по переданому артикулу и бренду из первого метода ""CRBRAND"" <br />
		| В теле запроса нужна Структура(""Арт,Бренд"") - тип текст; <br />
		|  <br />
		| <br />
		| <br />
		| Возврат 200 если метод отработал успешно
		|
		|
		|</BODY>
		|</HTML>	
		|
		|";
	
КонецФункции

Функция Запрос1бренды(Тело,КодОтвета) Экспорт
	
	Стк = XMLЗначение(ТИп("ХранилищеЗначения"),Тело).Получить();
	Если ТипЗнч(Стк)<>Тип("Структура") Тогда
		КодОтвета = 301;
		Возврат Хелп();
	КонецЕсли;
	
	Response = Запросqwep("brandsbyarticle",Стк.Арт);
	Если  ТИПЗнч(Response)=Тип("Строка") Тогда
		КодОтвета = 202;
		Возврат Response;
	КонецЕСЛИ;
	
	рез = Новый МАссив;
	Для каждого соо  из  Response Цикл
		рез.Добавить(соо.получить("brand"));
	КонецЦикла;
	
	хр = Новый ХранилищеЗначения(Рез);
	Возврат XMLСтрока(хр);

КонецФункции

Функция ПолучитьТело(Арт,бренд=Неопределено)
	
	Стк = Новый Структура;
	Стк.Вставить("article",СокрЛП(Арт));
	Если  бренд<>Неопределено Тогда
		Стк.Вставить("brand",СокрЛП(бренд));
	КонецЕсли;
	
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON,Стк);
	
	Возврат ЗаписьJSON.Закрыть();
	
КонецФункции

Функция Запросqwep(метод,полеАртикул,полеБренд=Неопределено)
	
	ssl1 = Новый ЗащищенноеСоединениеOpenSSL(
	Новый СертификатКлиентаWindows(),
	Новый СертификатыУдостоверяющихЦентровWindows());	 
	
	Соединение = Новый HTTPСоединение(
	"api.qwep.ru", // сервер (хост)
	443, // порт, по умолчанию для http используется 80, для https 443
	, // пользователь для доступа к серверу (если он есть)
	, // пароль для доступа к серверу (если он есть)
	, // здесь указывается прокси, если он есть
	, // таймаут в секундах, 0 или пусто - не устанавливать
	ssl1// защищенное соединение, если используется https
	);
	
	
	ТокенДоступа = "Bearer 9A7FD50D-1070-40DA-9FDF-125DD7E071B2";
	
	Запрос = Новый HTTPЗапрос("/crossapi/"+метод);
	Запрос.Заголовки.Вставить("Accept-Encoding", "gzip");
	Запрос.Заголовки.Вставить("Content-Type", "application/json; charset=utf-8");
	Запрос.Заголовки.Вставить("Authorization", Токен());
	
	Запрос.УстановитьТелоИзСтроки(ПолучитьТело(полеАртикул,полеБренд));
	
	
	Результат = Соединение.POST(Запрос);
	Если Результат.КодСостояния <> 200 или Результат.КодСостояния>210 Тогда 
		//Сообщить(результат.ПолучитьТелоКакСтроку());
		Возврат результат.ПолучитьТелоКакСтроку();
	КонецЕСЛИ;
	
	
	ДД = Результат.ПолучитьТелоКакДвоичныеДанные();
	Если ДД = Неопределено Тогда
		//Сообщить("Данные ответа не удалось прочитать, ресурс: ");
		Возврат "Данные ответа не удалось прочитать, ресурс: ";
	КонецЕсли;
	ДД = ПрочитатьGZip(ДД);
	ТелоОтвета = ПолучитьСтрокуИзДвоичныхДанных(ДД);
	
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(ТелоОтвета);
	Response = ПрочитатьJSON(ЧтениеJSON, Истина);
	ЧтениеJSON.Закрыть();
	
	Возврат Response;
	
КонецФункции


Функция Запрос2Аналоги(Тело,КодОтвета) Экспорт
	
	Стк = XMLЗначение(ТИп("ХранилищеЗначения"),Тело).Получить();
	Если ТипЗнч(Стк)<>Тип("Структура") Тогда
		КодОтвета = 301;
		Возврат Хелп();
	КонецЕсли;
	
	Response = Запросqwep("/crossitems",Стк.Арт,Стк.Бренд);
	Если  ТИПЗнч(Response)=Тип("Строка") Тогда
		КодОтвета = 309;
		Возврат Response;
	КонецЕСЛИ;
	
	
	Рез = Новый МАссив;
	
	Для каждого соо  из  Response Цикл
		
		Стк = Новый Структура();
		Для каждого эл из Соо Цикл
			Стк.Вставить(эл.ключ,эл.значение);
		КонецЦикла;
	    Рез.Добавить(Стк);
		
	КонецЦикла;
	

	хр = Новый ХранилищеЗначения(Рез);
	Возврат XMLСтрока(хр);
	
	
КонецФункции
